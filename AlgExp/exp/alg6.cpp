// 1．矩阵连乘问题
// 【问题描述】
// 给定n个矩阵{A1,A2,…,An}，其中Ai与Ai+1是可乘的，i=1,2…,n-1，如何确定矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积所需要的乘法次数最少。
// 例，有四个矩阵A, B, C, D，它们的维数分别是： A=50× 10， B=10× 40, C=40× 30, D=30× 5，连乘积ABCD共有五种完全加括号的方式：
//    矩阵连乘问题的乘法次数
//    (A((BC)D)) 16000        (A(B(CD))) 10500
//    ((AB)(CD)) 36000        (((AB)C)D) 87500
//    ((A(BC))D) 34500
// 运行示例:
// [输入]
// 连乘矩阵的个数:4
// 每个矩阵的大小:5 20 50 1 100
// [输出]
// 矩阵连乘最小计算量:1600
// 矩阵连乘所有组合方式:
// com[1][1]=0 com[1][2]=1 com[1][3]=1 com[1][4]=3
//             com[2][2]=0 com[2][3]=2 com[2][4]=3
//                         com[3][3]=0 com[3][4]=3
//                                     com[4][4]=0
// 矩阵连乘的计算量:
// m[1][1]=0    m[1][2]=5000 m[1][3]=1100 m[1][4]=1600
//              m[2][2]=0    m[2][3]=1000 m[2][4]=3000
//                           m[3][3]=0    m[3][4]=5000
//                                        m[4][4]=0
// #include <iostream>
// #include <iomanip>
// #include <cstring>
// using namespace std;
// const int N = 100;
// int n;
// int p[N], m[N][N], s[N][N];
// void matrixChain()
// {
//     memset(m, 0, sizeof(m));
//     for (int r = 2; r <= n; r++)
//     {
//         for (int i = 1; i <= n - r + 1; i++)
//         {
//             int j = i + r - 1;
//             m[i][j] = m[i + 1][j] + p[i - 1] * p[i] * p[j];
//             s[i][j] = i;
//             for (int k = i + 1; k < j; k++)
//             {
//                 int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
//                 if (t < m[i][j])
//                 {
//                     m[i][j] = t;
//                     s[i][j] = k;
//                 }
//             }
//         }
//     }
// }
// void getSol(int i, int j)
// {
//     if (i == j)
//         cout << "A" << i;
//     else
//     {
//         cout << "(";
//         getSol(i, s[i][j]);
//         getSol(s[i][j] + 1, j);
//         cout << ")";
//     }
// }
// int main()
// {
//     cout << "请输入连乘矩阵的个数:"; 
//     cin >> n;
//     cout << "请输入各连乘矩阵的大小:";
//     for (int i = 0; i <= n; i++) cin >> p[i];
//     matrixChain();
//     cout << "矩阵连乘最小的计算量:" << m[1][n] << endl;
//     cout << "下面的二维矩阵com[i][j]记录了矩阵连乘的组合方式:" << endl;
//     for (int i = 1; i <= n; i++)
//     {
//         for (int j = 1; j <= n; j++)
//         {
//             if (j >= i)
//                 cout << "com[" << i << "][" << j << "]=" << s[i][j] << " ";
//             else
//                 cout << "            ";
//         }
//         cout << endl;
//     }
//     cout << "下面的二维矩阵com[i][j]记录了矩阵连乘的计算量:" << endl;
//     for (int i = 1; i <= n; i++)
//     {
//         for (int j = 1; j <= n; j++)
//         {
//             if (j >= i)
//                 cout << "m[" << i << "][" << j << "]=" << left << setw(5) << m[i][j] << " ";
//             else
//                 cout << "              ";
//         }
//         cout << endl;
//     }
//     cout << "-----------------" << endl;
//     getSol(1, n);
//     cout << endl << "-----------------" << endl;
//     return 0;
// }
// 这段代码使用了动态规划来解决矩阵链乘问题。矩阵链乘问题是指给定一系列矩阵，求出一种最优的计算顺序，使得计算这些矩阵的乘积所需的标量乘法次数最少。

// 在这段代码中，`matrixChain` 函数实现了动态规划算法。它使用了两个二维数组 `m` 和 `s`。`m[i][j]` 表示计算矩阵 `Ai...Aj` 的乘积所需的最少标量乘法次数，`s[i][j]` 表示计算矩阵 `Ai...Aj` 的乘积时，最优的断点位置。

// 函数首先初始化了 `m` 数组，然后使用了三层循环来计算 `m` 和 `s`
// 数组。外层循环枚举子问题的规模，中间层循环枚举子问题的起点，内层循环枚举断点位置。在内层循环中，函数计算了在断点位置为
// `k` 时，计算矩阵 `Ai...Aj` 的乘积所需的标量乘法次数，并更新 `m[i][j]` 和
// `s[i][j]`。

// 在主函数中，首先调用了 `matrixChain` 函数来计算最优解，然后输出了最优解的值和对应的计算顺序。

// 这个算法的时间复杂度为 O(n^3)，其中 n 为矩阵的个数。


// 最大字段和
// 【问题描述】
// 给定由n个整数组成的序列a1,a2,...,an，求该序列子段和的最大值。当所有整数均为负值时定义其最大子段和为0。
// 依此定义， 例如， 当(a1,a2, a3, a4, a5,a6)=(-2, 11, -4, 13, -5, -2)时，最大子段和为20。
// 给出算法设计思想，并用动态规划算法实现。

// 这是一个经典的最大子段和问题，可以使用动态规划算法来解决。动态规划的思想是将原问题分解为若干个子问题，然后逐个求解子问题，最终得到原问题的解。
// 在这个问题中，我们可以定义状态dp[i]表示以第i个元素结尾的最大子段和。那么，对于第i个元素，它可以选择加入前面的子段，也可以选择单独成为一个新的子段。因此，状态转移方程为dp[i] = max(dp[i-1]+a[i], a[i])。初始状态为dp[1] = a[1]。
// 这个算法的时间复杂度为O(n)，其中n为序列的长度。因为我们只需要遍历一遍序列，对于每个元素都进行一次状态转移即可。

#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int n;
    cin >> n;

    int a[n + 1], dp[n + 1];
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    dp[1] = a[1];
    for (int i = 2; i <= n; i++)
    {
        dp[i] = max(dp[i - 1] + a[i], a[i]);
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        ans = max(ans, dp[i]);
    }
    cout << ans << endl;
    return 0;
}
